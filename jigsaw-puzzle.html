<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jigsaw Puzzle App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            touch-action: none;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            margin-bottom: 20px;
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .setup-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }

        input[type="file"] {
            padding: 15px;
            border: 2px dashed #667eea;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            background: #f8f9ff;
        }

        input[type="file"]:hover {
            background: #eef1ff;
        }

        .piece-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .piece-option {
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            background: white;
            transition: all 0.3s;
        }

        .piece-option:hover {
            background: #f0f0f0;
        }

        .piece-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .btn {
            padding: 18px 40px;
            font-size: 1.2em;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #48bb78;
            color: white;
        }

        .btn-secondary:hover {
            background: #38a169;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(72, 187, 120, 0.4);
        }

        .game-area {
            display: none;
            flex-direction: column;
            gap: 20px;
        }

        .game-area.active {
            display: flex;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .puzzle-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .puzzle-board, .pieces-tray {
            border: 3px solid #667eea;
            border-radius: 15px;
            background: #f8f9ff;
            position: relative;
            min-height: 400px;
        }

        .puzzle-board {
            background-image: 
                linear-gradient(rgba(102, 126, 234, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(102, 126, 234, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .puzzle-piece {
            position: absolute;
            cursor: move;
            touch-action: none;
            transition: transform 0.1s;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .puzzle-piece:active {
            cursor: grabbing;
            z-index: 1000;
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .puzzle-piece.correct {
            border: 2px solid #48bb78;
            cursor: default;
            box-shadow: 0 0 15px rgba(72, 187, 120, 0.5);
        }

        .stats {
            text-align: center;
            padding: 15px;
            background: #eef1ff;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            color: #667eea;
        }

        .success-message {
            display: none;
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            border-radius: 15px;
            font-size: 1.5em;
            font-weight: 700;
            animation: celebrate 0.5s ease-out;
        }

        .success-message.show {
            display: block;
        }

        @keyframes celebrate {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .puzzle-container {
                grid-template-columns: 1fr;
            }
            
            .piece-selector {
                grid-template-columns: repeat(4, 1fr);
            }

            h1 {
                font-size: 1.5em;
            }
        }

        .board-label {
            text-align: center;
            font-weight: 600;
            color: #667eea;
            padding: 10px;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§© Jigsaw Puzzle App</h1>
        
        <div class="setup-panel" id="setupPanel">
            <div class="input-group">
                <label for="imageInput">Choose Your Picture:</label>
                <input type="file" id="imageInput" accept="image/*" capture="environment">
            </div>

            <div class="input-group">
                <label>Select Number of Pieces:</label>
                <div class="piece-selector">
                    <div class="piece-option" data-pieces="30">30</div>
                    <div class="piece-option selected" data-pieces="40">40</div>
                    <div class="piece-option" data-pieces="50">50</div>
                    <div class="piece-option" data-pieces="60">60</div>
                    <div class="piece-option" data-pieces="70">70</div>
                    <div class="piece-option" data-pieces="80">80</div>
                    <div class="piece-option" data-pieces="90">90</div>
                    <div class="piece-option" data-pieces="100">100</div>
                </div>
            </div>

            <button class="btn btn-primary" id="startBtn" disabled>Start Puzzle</button>
        </div>

        <div class="game-area" id="gameArea">
            <div class="success-message" id="successMessage">
                ðŸŽ‰ Congratulations! Puzzle Complete! ðŸŽ‰
            </div>

            <div class="stats" id="stats">
                Pieces Placed: <span id="placedCount">0</span> / <span id="totalCount">0</span>
            </div>

            <div class="controls">
                <button class="btn btn-secondary" id="newPuzzleBtn">New Puzzle</button>
            </div>

            <div class="puzzle-container">
                <div>
                    <div class="board-label">Puzzle Board</div>
                    <div class="puzzle-board" id="puzzleBoard"></div>
                </div>
                <div>
                    <div class="board-label">Puzzle Pieces</div>
                    <div class="pieces-tray" id="piecesTray"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedImage = null;
        let selectedPieceCount = 40;
        let currentPuzzle = null;

        // Piece selection
        document.querySelectorAll('.piece-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.piece-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedPieceCount = parseInt(option.dataset.pieces);
            });
        });

        // Image upload
        document.getElementById('imageInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    selectedImage = event.target.result;
                    document.getElementById('startBtn').disabled = false;
                };
                reader.readAsDataURL(file);
            }
        });

        // Start puzzle button
        document.getElementById('startBtn').addEventListener('click', () => {
            if (selectedImage) {
                startPuzzle(selectedImage, selectedPieceCount);
            }
        });

        // New puzzle button
        document.getElementById('newPuzzleBtn').addEventListener('click', () => {
            document.getElementById('gameArea').classList.remove('active');
            document.getElementById('setupPanel').style.display = 'flex';
            document.getElementById('successMessage').classList.remove('show');
            document.getElementById('imageInput').value = '';
            document.getElementById('startBtn').disabled = true;
            selectedImage = null;
        });

        function startPuzzle(imageSrc, pieceCount) {
            document.getElementById('setupPanel').style.display = 'none';
            document.getElementById('gameArea').classList.add('active');
            document.getElementById('successMessage').classList.remove('show');

            const img = new Image();
            img.onload = () => {
                createPuzzle(img, pieceCount);
            };
            img.src = imageSrc;
        }

        function createPuzzle(img, totalPieces) {
            const puzzleBoard = document.getElementById('puzzleBoard');
            const piecesTray = document.getElementById('piecesTray');
            puzzleBoard.innerHTML = '';
            piecesTray.innerHTML = '';

            // Calculate grid dimensions
            const aspectRatio = img.width / img.height;
            let cols, rows;
            
            // Find optimal grid layout
            cols = Math.round(Math.sqrt(totalPieces * aspectRatio));
            rows = Math.round(totalPieces / cols);
            
            // Adjust to get exact piece count
            while (cols * rows < totalPieces) {
                if (cols * aspectRatio < rows) cols++;
                else rows++;
            }
            while (cols * rows > totalPieces) {
                if (cols * aspectRatio > rows) cols--;
                else rows--;
            }

            const actualPieces = cols * rows;
            document.getElementById('totalCount').textContent = actualPieces;
            document.getElementById('placedCount').textContent = '0';

            // Set board size
            const boardWidth = Math.min(puzzleBoard.parentElement.clientWidth - 40, 600);
            const boardHeight = boardWidth / aspectRatio;
            puzzleBoard.style.width = boardWidth + 'px';
            puzzleBoard.style.height = boardHeight + 'px';

            const pieceWidth = boardWidth / cols;
            const pieceHeight = boardHeight / rows;

            // Create canvas for image slicing
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const pieces = [];
            const pieceImgWidth = img.width / cols;
            const pieceImgHeight = img.height / rows;

            // Create puzzle pieces
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const pieceCanvas = document.createElement('canvas');
                    pieceCanvas.width = pieceImgWidth;
                    pieceCanvas.height = pieceImgHeight;
                    const pieceCtx = pieceCanvas.getContext('2d');

                    pieceCtx.drawImage(
                        canvas,
                        col * pieceImgWidth, row * pieceImgHeight,
                        pieceImgWidth, pieceImgHeight,
                        0, 0,
                        pieceImgWidth, pieceImgHeight
                    );

                    const piece = document.createElement('div');
                    piece.className = 'puzzle-piece';
                    piece.style.width = pieceWidth + 'px';
                    piece.style.height = pieceHeight + 'px';
                    piece.style.backgroundImage = `url(${pieceCanvas.toDataURL()})`;
                    piece.style.backgroundSize = 'cover';
                    piece.dataset.correctX = col * pieceWidth;
                    piece.dataset.correctY = row * pieceHeight;
                    piece.dataset.col = col;
                    piece.dataset.row = row;

                    pieces.push(piece);
                }
            }

            // Shuffle pieces
            shuffleArray(pieces);

            // Add pieces to tray
            const trayWidth = piecesTray.clientWidth - 40;
            const piecesPerRow = Math.floor(trayWidth / pieceWidth);
            
            pieces.forEach((piece, index) => {
                const trayRow = Math.floor(index / piecesPerRow);
                const trayCol = index % piecesPerRow;
                
                piece.style.left = (20 + trayCol * (pieceWidth + 5)) + 'px';
                piece.style.top = (20 + trayRow * (pieceHeight + 5)) + 'px';
                
                piecesTray.appendChild(piece);
                makeDraggable(piece, puzzleBoard, piecesTray, pieceWidth, pieceHeight);
            });

            currentPuzzle = {
                totalPieces: actualPieces,
                placedPieces: 0,
                pieceWidth,
                pieceHeight
            };
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function makeDraggable(piece, board, tray, pieceWidth, pieceHeight) {
            let isDragging = false;
            let currentX, currentY;
            let initialX, initialY;
            let xOffset = 0, yOffset = 0;

            const dragStart = (e) => {
                if (piece.classList.contains('correct')) return;

                if (e.type === 'touchstart') {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }

                if (e.target === piece) {
                    isDragging = true;
                    piece.style.zIndex = 1000;
                }
            };

            const drag = (e) => {
                if (isDragging) {
                    e.preventDefault();

                    if (e.type === 'touchmove') {
                        currentX = e.touches[0].clientX - initialX;
                        currentY = e.touches[0].clientY - initialY;
                    } else {
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                    }

                    xOffset = currentX;
                    yOffset = currentY;

                    piece.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
            };

            const dragEnd = (e) => {
                if (isDragging) {
                    isDragging = false;
                    piece.style.zIndex = 1;

                    // Get drop position
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        clientX = e.changedTouches[0].clientX;
                        clientY = e.changedTouches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    const boardRect = board.getBoundingClientRect();
                    const isOverBoard = clientX >= boardRect.left && clientX <= boardRect.right &&
                                       clientY >= boardRect.top && clientY <= boardRect.bottom;

                    if (isOverBoard) {
                        // Calculate position relative to board
                        const x = clientX - boardRect.left - pieceWidth / 2;
                        const y = clientY - boardRect.top - pieceHeight / 2;

                        // Snap to grid
                        const snapX = Math.round(x / pieceWidth) * pieceWidth;
                        const snapY = Math.round(y / pieceHeight) * pieceHeight;

                        // Check if correct position
                        const correctX = parseFloat(piece.dataset.correctX);
                        const correctY = parseFloat(piece.dataset.correctY);
                        const tolerance = pieceWidth * 0.3;

                        if (Math.abs(snapX - correctX) < tolerance && Math.abs(snapY - correctY) < tolerance) {
                            // Correct position
                            if (piece.parentElement !== board) {
                                board.appendChild(piece);
                            }
                            piece.style.left = correctX + 'px';
                            piece.style.top = correctY + 'px';
                            piece.style.transform = 'none';
                            piece.classList.add('correct');
                            xOffset = 0;
                            yOffset = 0;

                            currentPuzzle.placedPieces++;
                            document.getElementById('placedCount').textContent = currentPuzzle.placedPieces;

                            if (currentPuzzle.placedPieces === currentPuzzle.totalPieces) {
                                setTimeout(() => {
                                    document.getElementById('successMessage').classList.add('show');
                                }, 300);
                            }
                        } else {
                            // Wrong position, place on board anyway
                            if (piece.parentElement !== board) {
                                board.appendChild(piece);
                            }
                            piece.style.left = Math.max(0, Math.min(snapX, boardRect.width - pieceWidth)) + 'px';
                            piece.style.top = Math.max(0, Math.min(snapY, boardRect.height - pieceHeight)) + 'px';
                            piece.style.transform = 'none';
                            xOffset = 0;
                            yOffset = 0;
                        }
                    } else {
                        // Return to original position
                        piece.style.transform = 'none';
                        xOffset = 0;
                        yOffset = 0;
                    }
                }
            };

            piece.addEventListener('touchstart', dragStart, { passive: false });
            piece.addEventListener('touchmove', drag, { passive: false });
            piece.addEventListener('touchend', dragEnd, { passive: false });
            piece.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
        }
    </script>
</body>
</html>
